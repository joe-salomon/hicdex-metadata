{"__version": 1, "token_id": 567646, "symbol": "OBJKT", "name": "tide", "description": "// please zoom for details\n// 2160x2160\n\n#define PI 3.141592653589793\n#define TWO_PI 6.283185307179586\n#define MAX_STEPS 64\n#define DISTANCE_THRESHOLD 0.0001\n\nfloat sphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat plane(vec3 p, float height) {\n    return p.z - height;\n}\n\nfloat box(in vec3 p, in vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat f( in vec3 p ) {\n    float spacing = 2.0 * PI / 3.0;\n\n    vec3 sp0 = vec3(0.5, 0.5, 0.5);\n    \n    vec3 w = vec3( fract(p.x / 4.0), fract(p.y / 4.0), fract(p.z / 4.0) );\n    \n    float t = 1.0 / 16.0;\n    float v = 1.0 / 16.0;\n    float l = 3.0 / 16.0;\n    float d = box(sp0 - w, vec3(l, t, t));\n    d = min(d, box(sp0 - w, vec3(t, l, t)));\n    d = min(d, box(sp0 - w, vec3(t, t, l)));\n    \n    return d;\n}\n\nvec3 get_normal( in vec3 p ) {  // sample along 3 axes to get a normal  \n    const float o = 0.0009765625;\n    float c = f(p); \n    const vec2 h = vec2(o, 0);\n    return normalize(vec3( f(p + h.xyy) - c,\n                           f(p + h.yxy) - c,\n                           f(p + h.yyx) - c) );\n}\n\nfloat cast_ray(inout vec3 p, in vec3 h) {\n    float depth = 0.0;\n    float d;\n    for (int a = 0; a < MAX_STEPS; a ++) {\n        d = f(p);    \n        p += d * h;   \n        depth += d;\n        if (d < DISTANCE_THRESHOLD) {\n            break;\n        }\n    }\n    return d;\n}\n\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void) { seed=seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n\nint hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n\nvec3 spherical() {\n    float z = frand() * 2.0 - 1.0;\n    float angle = TWO_PI * frand();\n    return vec3( sqrt(1.0 - z*z) * cos(angle), \n                 sqrt(1.0 - z*z) * sin(angle),\n                 z );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 q = ivec2(gl_FragCoord); \n    srand(hash(q.x + hash(q.y + hash(int(1000.0 * iTime)))));\n\n    vec2 uv = 1.0 * (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y; \n\n    float pitch = PI * 1.0 / 3.0 * sin(0.021193 * iTime);\n    float heading = PI * sin(0.082315 * iTime);\n    vec3 pos = vec3(iTime + 1.0, iTime, iTime + 3.0);\n    pos = 4.0 * vec3( fract( 0.25 * pos.x ),\n                      fract( 0.25 * pos.y ),\n                      fract( 0.25 * pos.z ) );\n    vec3 h = vec3( cos(heading) * cos(pitch), \n                   sin(heading) * cos(pitch), \n                   sin(pitch));\n    vec3 x_in_screen = vec3(0.0, 0.0, 1.0);   // z axis\n    h = -normalize(h);        \n    vec3 i = cross(h, x_in_screen);           //  x in screen \n    vec3 j = cross(i, h);                     // y in screen \n    \n    h += i * uv.x; h += j * uv.y; \n    normalize(h);\n    vec3 light = vec3(0.5, 0.25, 0.5);\n    normalize(light);\n    float d = cast_ray(pos, h); \n    vec3 normal = get_normal(pos);\n    float s = 1.0;\n    \n    for (float i = 0.0; i < 1.0; i += 0.25) {\n        float occlusion_offset = 0.1 * i * i;\n        s -= 32.0 * clamp(0.25 * ( (occlusion_offset + d)\n                           - f(pos + occlusion_offset * normal) ), \n                           0.0, 1.0);\n    }\n    \n    float value = 0.25 * dot(h, normal);\n    float fog = (1.0 - 1.0 / (length(pos) * 0.005 + 1.0));\n\n    value += 1.0 / 8.0 * (frand() - 0.5);\n    value = value * s + fog;\n\n    fragColor = vec4( value, value, value, 1.0 );\n}", "artifact_uri": "ipfs://QmQitbaUY9m4oMbzF41hf8sRwQQZ2hb72yk5tdua7PxTb3", "display_uri": "ipfs://QmNs42sLu8GMdWWQMsw54y55G69a782tEZxQtgKXF4nj7Y", "thumbnail_uri": "ipfs://QmNrhZHUaEqxhyLfqoq1mtHSipkWHeT31LNHb1QEbDHgnc", "formats": [{"uri": "ipfs://QmQitbaUY9m4oMbzF41hf8sRwQQZ2hb72yk5tdua7PxTb3", "mimeType": "image/png"}], "creators": ["tz1eBQkbLx1qgjjXSGDjm5yLB7pbP8LZD3LB"], "tags": ["generativeart", "code", "math", "texture"], "extra": {}}