{"__version": 1, "token_id": 527900, "symbol": "OBJKT", "name": "Interpolation From a Circle to an Equilateral Triangle (#12)", "description": "/*\n * \u25ef\u27f7\u25b3 \u2116.12\n * Interpolation From a Circle to an Equilateral Triangle (#12)\n * \"By treating the form as a series of six circular arcs, \n * whose radii alternate betwen small and large.\"\n * Page Twelve of a 14-Page Pedagogical Sketchbook \n * By Golan Levin (@golan), 2017-2021.\n * \n * Animated GIF, 1024x1024, 720 frames @50fps, made with p5.js;\n * Presented October 25, 2017 on the Coding Train episode,\n * \"Guest Tutorial #7: Circle Morphing with Golan Levin\"\n * (https://www.youtube.com/watch?v=mvgcNOX8JGQ&t=1315s).\n * NFT created in 2021 for #Sketch4Processing, and minted by\n * KT1TaPfAuhmnyo6Le6zKe17opvFCsTxk1VN7 (golan_x_processingorg).\n * Per contract, 20% of all sales are donated to @ProcessingOrg.\n * \n * References: \n * - Joseph Choma, \"Morphing: A Guide to Mathematical\n *   Transformations for Architects and Designers\", 2015.\n * - Guus Craenen and Adrian H\u00e4ne, \"Fruit Salad\", 1970.\n * - CTG Japan (Masao Kohmura, Koji Fujino, Makoto Ohtake),\n *   \"Running Cola is Africa!\", 1968.\n * - Wassily Kandinsky, \"Point and Line to Plane\", 1926.\n * - William Kolomyjec, \"Banana Cone\", 1970-1975.\n * - J\u00fcrg Lehni and Wilm Thoben, \"Footnotes from the History\n *   of Two Cultures: Mitsuo Katsui\", 2015.\n * - Manfred Mohr, \"P-112 / Lady Quark\", 1972.\n * - Bruno Munari, \"Square Circle Triangle\", 1960-1976.\n * - Charles Philipon, \"Les Poires\", 1831.\n * - Troika, \"Squaring the Circle\"; \"Dark Matter\", 2013-2014.\n * - Wucius Wong, \"Principles of Two-Dimensional Design\", 1972.\n * - Yuki Yoshida, \"A Book of drawCircle()\", 2014.\n */\n\nvar radius;\nvar cx,cy;\nvar trianglePoints = []; \nvar nFrames = 360;\nvar nLoops = 2;\nvar backgrCol;\nvar strokeCol;\n\nfunction setup() {\n  createCanvas(1024, 1024);\n  pixelDensity(1);\n  frameRate(60);\n\n  backgrCol = color(253,247,241);\n  strokeCol = color(24,14,6);\n\n  radius = (width/2) * 0.75;\n  cx = width/2;\n  cy = height/2;\n\n  for (var i=0; i<3; i++) { // triangle vertices\n    var x = cx + radius * cos(i * TWO_PI/3.0 - HALF_PI);\n    var y = cy + radius * sin(i * TWO_PI/3.0 - HALF_PI);\n    trianglePoints[i] = { x,y };\n  }  \n}\n\nfunction draw() {\n  background(backgrCol);\n  strokeJoin(ROUND);\n  noFill();\n  \n  var strokeWeight1 = ceil(width * 0.01);\n  var strokeWeight2 = width / 1024.0;\n\n  var frac = ((frameCount / nLoops) % nFrames) / nFrames;\n  var theta = TWO_PI * frac;\n  var wiggle = 0.5 + 0.5 * cos(theta);\n  var rad = (1.0 - wiggle) * radius;\n  var bDrawDebug = (frac < 0.5);\n\n  if (rad === 0){\n    stroke(strokeCol);\n    strokeWeight(strokeWeight1);\n    beginShape();\n    vertex(trianglePoints[0].x, trianglePoints[0].y);\n    vertex(trianglePoints[1].x, trianglePoints[1].y);\n    vertex(trianglePoints[2].x, trianglePoints[2].y);\n    endShape(CLOSE);\n    \n  } else {\n    for (var i=0; i<3; i++){\n      var j = (i+1)%3;\n      var tx1 = trianglePoints[i].x;\n      var ty1 = trianglePoints[i].y;\n      var tx2 = trianglePoints[j].x;\n      var ty2 = trianglePoints[j].y;\n\n      var px1 = lerp(cx, tx1, wiggle);\n      var py1 = lerp(cy, ty1, wiggle);\n      var px2 = lerp(cx, tx2, wiggle);\n      var py2 = lerp(cy, ty2, wiggle);\n\n      var cornerArcAng = map(wiggle, 0, 1, 30.0, 59.99);\n      var sa1 = i * TWO_PI/3.0 - HALF_PI - radians(cornerArcAng);\n      var ea1 = i * TWO_PI/3.0 - HALF_PI + radians(cornerArcAng);\n      var sa2 = j * TWO_PI/3.0 - HALF_PI - radians(cornerArcAng);\n      var ea2 = j * TWO_PI/3.0 - HALF_PI + radians(cornerArcAng);\n\n      var x1 = px1 + rad * cos(ea1);\n      var y1 = py1 + rad * sin(ea1);\n      var x2 = x1 - 0.5 * rad * sin(ea1);\n      var y2 = y1 + 0.5 * rad * cos(ea1);\n\n      var x3 = px2 + rad * cos(sa2);\n      var y3 = py2 + rad * sin(sa2);\n      var x4 = x3 + 0.5 * rad * sin(sa2);\n      var y4 = y3 - 0.5 * rad * cos(sa2);\n\n      if (bDrawDebug){\n        strokeWeight(strokeWeight2);\n        stroke(24,14,6, 128 * wiggle);\n        ellipse(px1,py1, rad*2,rad*2);\n      }\n\n      // Construct perpendiculars\n      var bigR = 1000000;\n      var ppx = x1 - bigR * (y2-y1);\n      var ppy = y1 + bigR * (x2-x1);\n      var pqx = x3 - bigR * (y3-y4);\n      var pqy = y3 + bigR * (x3-x4);\n\n      // Compute the intersection of (x1,y1, ppx,ppy) and (x3,y3, pqx,pqy)\n      // Via Bourke: http://paulbourke.net/geometry/pointlineplane/\n      var numer = (pqx-x3)*(y1-y3) - (pqy-y3)*(x1-x3);\n      var denom = (pqy-y3)*(ppx-x1) - (pqx-x3)*(ppy-y1);\n      if (denom > 0) {\n        var u = numer / denom;\n        var acx = x1 + u*(ppx-x1);\n        var acy = y1 + u*(ppy-y1);\n        var arcD = 2.0 * dist(acx, acy, x1, y1);\n        var arcSa = atan2(y1-acy, x1-acx);\n        var arcEa = atan2(y3-acy, x3-acx);\n\n        if (bDrawDebug){\n          strokeWeight(strokeWeight2);\n          stroke(24,14,6, 128*(1.0 - wiggle));\n          ellipse(acx,acy, arcD,arcD);\n        }\n\n        stroke(strokeCol);\n        strokeWeight(strokeWeight1);\n        arc(acx,acy, arcD,arcD, arcSa,arcEa);\n      }\n\n      stroke(strokeCol);\n      strokeWeight(strokeWeight1);\n      arc(px1,py1, rad*2,rad*2, sa1,ea1);\n    }\n  }\n}\n  ", "artifact_uri": "ipfs://bafybeibzz2qp2nugyz6pnesaatowf6w6lq34nfiyn32h63a5o6hclfa6ey", "display_uri": "ipfs://bafybeibzz2qp2nugyz6pnesaatowf6w6lq34nfiyn32h63a5o6hclfa6ey", "thumbnail_uri": "ipfs://QmNrhZHUaEqxhyLfqoq1mtHSipkWHeT31LNHb1QEbDHgnc", "formats": [{"uri": "ipfs://bafybeibzz2qp2nugyz6pnesaatowf6w6lq34nfiyn32h63a5o6hclfa6ey", "mimeType": "image/gif"}], "creators": ["KT1TaPfAuhmnyo6Le6zKe17opvFCsTxk1VN7"], "tags": ["circle", "triangle", "shape", "interpolation", "metamorphosis", "morphing", "morph", "tween", "transformation", "transmutation", "lofting", "loop", "gif", "geometry", "creativecoding", "pedagogicalsketchbook", "series", "collabcontract", "sketch4processing", "sketchforprocessing", "Processing", "ProcessingOrg", "golan", "golanlevin"], "extra": {}}