{"__version": 1, "token_id": 498129, "symbol": "OBJKT", "name": "Interpolation From a Circle to an Equilateral Triangle (#10)", "description": "/*\n * \u25ef\u27f7\u25b3 \u2116.10\n * Interpolation From a Circle to an Equilateral Triangle (#10)\n * \"By treating points along the perimeter as a series\n * of springy particles.\"\n * Page Ten of a 14-Page Pedagogical Sketchbook \n * By Golan Levin (@golan), 2017-2021.\n * https://link.medium.com/bn3sesXYOkb\n * \n * Animated GIF, 1024x1024, 720 frames @50fps, made with p5.js;\n * Presented October 25, 2017 on the Coding Train episode,\n * \"Guest Tutorial #7: Circle Morphing with Golan Levin\"\n * (https://www.youtube.com/watch?v=mvgcNOX8JGQ&t=24m26s).\n * NFT created in 2021 for #Sketch4Processing, and minted by\n * KT1TaPfAuhmnyo6Le6zKe17opvFCsTxk1VN7 (golan_x_processingorg).\n * Per contract, 20% of all sales are donated to @ProcessingOrg.\n * \n * References: \n * - Guus Craenen and Adrian H\u00e4ne, \"Fruit Salad\", 1970.\n * - Wassily Kandinsky, \"Point and Line to Plane\", 1926.\n * - J\u00fcrg Lehni and Wilm Thoben, \"Footnotes from the History\n *   of Two Cultures: Mitsuo Katsui\", 2015.\n * - Manfred Mohr, \"P-112 / Lady Quark\", 1972.\n * - Bruno Munari, \"Square Circle Triangle\", 1960-1976.\n * - Troika, \"Squaring the Circle\"; \"Dark Matter\", 2013-2014.\n * - Wucius Wong, \"Principles of Two-Dimensional Design\", 1972.\n * - Yuki Yoshida, \"A Book of drawCircle()\", 2014.\n */\n\nvar nPts, third, offset;\nvar radius;\nvar cx, cy;\nvar trianglePts = [];\nvar srcPts = [];\nvar dstPts = [];\nvar targetPts = [];\nvar particles = [];\nvar target = 0;\nvar DAMPING = 0.96;\nvar MASS = 10;\nvar THRESH = 14.0;\nvar strokeCol;\nvar backgrCol;\n\nfunction setup() {\n  createCanvas(1024, 1024);\n  pixelDensity(1);\n  frameRate(60);\n  strokeCol = color(24, 14, 6, 255);\n  backgrCol = color(253, 247, 241);\n\n  nPts = 60;\n  third = nPts / 3;\n  offset = nPts / 12;\n  radius = width / 2 * 0.75;\n  cx = width / 2;\n  cy = height / 2;\n\n  for (var i = 0; i < 3; i++) {\n    var x = cx + radius * cos(i * TWO_PI / 3.0 - HALF_PI);\n    var y = cy + radius * sin(i * TWO_PI / 3.0 - HALF_PI);\n    trianglePts[i] = {x, y};\n  }\n\n  // compute srcPts: points on the circle\n  for (var j = 0; j < nPts; j++) {\n    var t = map(j, 0, nPts, 0, TWO_PI);\n    var x = cx + radius * cos(t);\n    var y = cy + radius * sin(t);\n    srcPts[j] = {x, y};\n  }\n\n  // compute dstPts: points along the triangle\n  for (var j = 0; j < nPts; j++) {\n    var i = (floor((j + nPts - offset) / third) + 1) % 3;\n    var p1x = trianglePts[i % 3].x;\n    var p1y = trianglePts[i % 3].y;\n    var p2x = trianglePts[(i + 1) % 3].x;\n    var p2y = trianglePts[(i + 1) % 3].y;\n\n    var jt = (j + nPts - (offset - 0)) % third;\n    var x = map(jt, 0, third, p1x, p2x);\n    var y = map(jt, 0, third, p1y, p2y);\n    targetPts[j] = dstPts[j] = {x, y};\n  }\n\n  for (var j = 0; j < nPts; j++) {\n    var px = srcPts[j].x;\n    var py = srcPts[j].y;\n    particles[j] = new Particle(px, py, 0, 0);\n  }\n}\n\nfunction draw() {\n  background(backgrCol);\n  noFill();\n  stroke(strokeCol);\n  strokeWeight(ceil(width * 0.01));\n\n  var error = 0;\n  for (var j = 0; j < nPts; j++) {\n    var px = particles[j].px;\n    var py = particles[j].py;\n    var tx = targetPts[j].x;\n    var ty = targetPts[j].y;\n    var dx = tx - px;\n    var dy = ty - py;\n    var dh = sqrt(dx*dx + dy*dy);\n    error += dh;\n    if (dh > 0) {\n      particles[j].applyForce(dx/dh, dy/dh);\n    }\n  }\n  if (error < THRESH) {\n    flipTarget();\n  }\n\n  var F = 0.5;\n  for (var j = 0; j < nPts; j++) {\n    var ix = particles[(j-1 + nPts) % nPts].px;\n    var iy = particles[(j-1 + nPts) % nPts].py;\n    var jx = particles[j % nPts].px;\n    var jy = particles[j % nPts].py;\n    var kx = particles[(j+1 + nPts) % nPts].px;\n    var ky = particles[(j+1 + nPts) % nPts].py;\n    var ijdx = ix-jx;\n    var ijdy = iy-jy;\n    var ijdh = sqrt(ijdx*ijdx + ijdy*ijdy);\n    if (ijdh > 0) {\n      var ifx = ijdx/ijdh * F;\n      var ify = ijdy/ijdh * F;\n      particles[j].applyForce(ifx, ify);\n    }\n    var kjdx = kx-jx;\n    var kjdy = ky-jy;\n    var kjdh = sqrt(kjdx*kjdx + kjdy*kjdy);\n    if (kjdh > 0) {\n      var kfx = kjdx/kjdh * F;\n      var kfy = kjdy/kjdh * F;\n      particles[j].applyForce(kfx, kfy);\n    }\n  }\n\n  for (var j = 0; j < nPts; j++) {\n    particles[j].update();\n  }\n\n  var ofs = 2;\n  beginShape();\n  var px = particles[ofs % nPts].px;\n  var py = particles[ofs % nPts].py;\n  curveVertex(px, py);\n  for (var j = 0; j < nPts; j++) {\n    px = particles[(j + ofs) % nPts].px;\n    py = particles[(j + ofs) % nPts].py;\n    curveVertex(px, py);\n  }\n  endShape(CLOSE);\n}\n\nfunction flipTarget() {\n  for (var j = 0; j < nPts; j++) {\n    x = (target === 1) ? dstPts[j].x : srcPts[j].x;\n    y = (target === 1) ? dstPts[j].y : srcPts[j].y;\n    targetPts[j] = {x, y};\n  }\n  target = 1-target;\n}\n\nfunction Particle(px, py, vx, vy) {\n  this.px = px;\n  this.py = py;\n  this.vx = vx;\n  this.vy = vy;\n\n  this.applyForce = function(fx, fy) {\n    this.vx += fx / MASS;\n    this.vy += fy / MASS;\n  }\n  this.update = function() {\n    this.vx *= DAMPING;\n    this.vy *= DAMPING;\n    this.px += this.vx;\n    this.py += this.vy;\n  }\n}", "artifact_uri": "ipfs://bafybeihapgyqfq62iazz3ybnuhi7gfsxgkrbpdsw7jk4uehcshlt773uzq", "display_uri": "ipfs://bafybeihapgyqfq62iazz3ybnuhi7gfsxgkrbpdsw7jk4uehcshlt773uzq", "thumbnail_uri": "ipfs://QmNrhZHUaEqxhyLfqoq1mtHSipkWHeT31LNHb1QEbDHgnc", "formats": [{"uri": "ipfs://bafybeihapgyqfq62iazz3ybnuhi7gfsxgkrbpdsw7jk4uehcshlt773uzq", "mimeType": "image/gif"}], "creators": ["KT1TaPfAuhmnyo6Le6zKe17opvFCsTxk1VN7"], "tags": ["circle", "triangle", "shape", "interpolation", "morphing", "morph", "tween", "transformation", "transmutation", "metamorphosis", "lofting", "loop", "gif", "geometry", "creativecoding", "pedagogicalsketchbook", "series", "collabcontract", "sketch4processing", "sketchforprocessing", "Processing", "ProcessingOrg", "golan", "golanlevin"], "extra": {}}