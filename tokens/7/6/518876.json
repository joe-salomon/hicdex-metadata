{"__version": 1, "token_id": 518876, "symbol": "OBJKT", "name": "Interpolation From a Circle to an Equilateral Triangle (#11)", "description": "/*\n * \u25ef\u27f7\u25b3 \u2116.11\n * Interpolation From a Circle to an Equilateral Triangle (#11)\n * \"By progressively moving points evenly sampled along the circle, \n * towards points on the triangle, resampled at equal intervals, \n * by small random amounts.\"\n * Page Eleven of a 14-Page Pedagogical Sketchbook \n * By Golan Levin (@golan), 2017-2021.\n * https://link.medium.com/bn3sesXYOkb\n * \n * Animated GIF, 1024x1024, 624 frames @~50fps, made with p5.js;\n * Presented October 25, 2017 on the Coding Train episode,\n * \"Guest Tutorial #7: Circle Morphing with Golan Levin\"\n * (https://www.youtube.com/watch?v=mvgcNOX8JGQ&t=12m7s).\n * NFT created in 2021 for #Sketch4Processing, and minted by\n * KT1TaPfAuhmnyo6Le6zKe17opvFCsTxk1VN7 (golan_x_processingorg).\n * Per contract, 20% of all sales are donated to @ProcessingOrg.\n * \n * References: \n * - Joseph Choma, \"Morphing: A Guide to Mathematical\n *   Transformations for Architects and Designers\", 2015.\n * - Guus Craenen and Adrian H\u00e4ne, \"Fruit Salad\", 1970.\n * - CTG Japan (Masao Kohmura, Koji Fujino, Makoto Ohtake),\n *   \"Running Cola is Africa!\", 1968.\n * - Wassily Kandinsky, \"Point and Line to Plane\", 1926.\n * - J\u00fcrg Lehni and Wilm Thoben, \"Footnotes from the History\n *   of Two Cultures: Mitsuo Katsui\", 2015.\n * - Manfred Mohr, \"P-112 / Lady Quark\", 1972.\n * - Bruno Munari, \"Square Circle Triangle\", 1960-1976.\n * - Troika, \"Squaring the Circle\"; \"Dark Matter\", 2013-2014.\n * - Wucius Wong, \"Principles of Two-Dimensional Design\", 1972.\n * - Yuki Yoshida, \"A Book of drawCircle()\", 2014.\n */\n \nvar nPoints, third, offset;\nvar radius;\nvar cx, cy;\nvar trianglePoints = []; // the 3 vertices of the triangle\nvar srcPoints = []; // points along the circle\nvar dstPoints = []; // points along the triangle\nvar curPercents = []; // percentages of interpolation\nvar durPercents = [];\nvar nFrames = 720;\nvar targetPercent = 1;\nvar strokeCol;\nvar backgrCol;\n\nfunction setup() {\n  createCanvas(1024, 1024);\n  pixelDensity(1);\n  frameRate(60);\n  strokeCol = color(24, 14, 6, 255);\n  backgrCol = color(253, 247, 241);\n\n  nPoints = 60;\n  third = nPoints/3;\n  offset = nPoints/12;\n  radius = (width/2) * 0.75;\n  cx = width/2;\n  cy = height/2;\n\n  for (var i=0; i<3; i++) {\n    var x = cx + radius * cos((i * TWO_PI) / 3.0 - HALF_PI);\n    var y = cy + radius * sin((i * TWO_PI) / 3.0 - HALF_PI);\n    trianglePoints[i] = { x,y };\n  }\n\n  // compute srcPoints: points on the circle\n  for (var j=0; j<nPoints; j++) {\n    durPercents[j] = curPercents[j] = 0.0;\n    var t = map(j, 0, nPoints, 0, TWO_PI);\n    var x = cx + radius * cos(t);\n    var y = cy + radius * sin(t);\n    srcPoints[j] = { x,y };\n  }\n\n  // compute dstPoints: points along the triangle\n  for (var j=0; j<nPoints; j++) {\n    var i = (floor((j+nPoints-offset) / third)+1)%3;\n    var p1x = trianglePoints[(i+0)%3].x;\n    var p1y = trianglePoints[(i+0)%3].y;\n    var p2x = trianglePoints[(i+1)%3].x;\n    var p2y = trianglePoints[(i+1)%3].y;\n\n    var jt = (j+nPoints-offset) % third;\n    var x = map(jt, 0,third, p1x,p2x);\n    var y = map(jt, 0,third, p1y,p2y);\n    dstPoints[j] = { x,y };\n  }\n}\n\nfunction draw() {\n  background(backgrCol);\n  noFill();\n  strokeCap(ROUND);\n  stroke(strokeCol);\n  strokeWeight(ceil(width * 0.01));\n\n  var i,j,k;\n\n  // move the curPercents inward, randomly\n  var speed = 0.012;\n  var bias = targetPercent === 1 ? 0.15 : 0.85;\n  var progress = (frameCount % nFrames) / nFrames; // 0...1\n  for (j=0; j<nPoints; j++) {\n    curPercents[j] += speed * (noise((j + progress) * 10) - bias);\n    curPercents[j] = constrain(curPercents[j], 0,1);\n    durPercents[j] = curPercents[j];\n  }\n\n  // blur the boundary, and calculate the error\n  var A = 0.98;\n  var B = (1.0-A) / 2.0;\n  for (j=0; j<nPoints; j++) {\n    i = (j-1+nPoints) % nPoints;\n    k = (j+1) % nPoints;\n    curPercents[j] =\n      B*durPercents[i] + A*durPercents[j] + B*durPercents[k];\n  }\n\n  /*\n  // An alternative way to decide when to switch is to \n  // accumulate error, then check if e.g. errorSum < 0.0001\n  var errorSum = 0;\n  for (j=0; j<nPoints; j++) {\n    errorSum += abs(targetPercent - curPercents[j]);\n  }\n  */\n  \n  // switch directions if it's close to our current target\n  if (frameCount % (nFrames/2) == 0) {\n    for (var j=0; j<nPoints; j++) {\n      curPercents[j] = targetPercent;\n    }\n    targetPercent = 1.0 - targetPercent;\n    noiseSeed(millis());\n  }\n\n  // render using polycurves\n  for (i=0; i<3; i++) {\n    var begin = i * third;\n    var end = (i+1) * third;\n    var px, py;\n    beginShape();{\n      px = trianglePoints[(i+1)%3].x;\n      py = trianglePoints[(i+1)%3].y;\n      vertex(px, py);\n      for (j=begin; j<end; j++) {\n        k = (j+offset+nPoints) % nPoints;\n        px = map(curPercents[k], 0,1, srcPoints[k].x,dstPoints[k].x);\n        py = map(curPercents[k], 0,1, srcPoints[k].y,dstPoints[k].y);\n        curveVertex(px, py);\n      }\n      px = trianglePoints[(i+2)%3].x;\n      py = trianglePoints[(i+2)%3].y;\n      vertex(px, py);\n      vertex(px, py);\n    }\n    endShape();\n  }\n}", "artifact_uri": "ipfs://bafybeia2dlr7t7twqbme4hzmb74pva5n6tgrhtycxoczkravx2437sxuhm", "display_uri": "ipfs://bafybeia2dlr7t7twqbme4hzmb74pva5n6tgrhtycxoczkravx2437sxuhm", "thumbnail_uri": "ipfs://QmNrhZHUaEqxhyLfqoq1mtHSipkWHeT31LNHb1QEbDHgnc", "formats": [{"uri": "ipfs://bafybeia2dlr7t7twqbme4hzmb74pva5n6tgrhtycxoczkravx2437sxuhm", "mimeType": "image/gif"}], "creators": ["KT1TaPfAuhmnyo6Le6zKe17opvFCsTxk1VN7"], "tags": ["circle", "triangle", "shape", "interpolation", "metamorphosis", "morphing", "morph", "tween", "transformation", "transmutation", "lofting", "loop", "gif", "geometry", "creativecoding", "pedagogicalsketchbook", "series", "collabcontract", "sketch4processing", "sketchforprocessing", "Processing", "ProcessingOrg", "golan", "golanlevin"], "extra": {}}